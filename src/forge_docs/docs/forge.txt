# FORGE
An advanced 3D Gaussian Splatting renderer for THREE.js
Integrate in your scene with other meshes and splats, fast rendering on all devices, programmable dynamic splat effects, wide format support (ply, spz, splat, ksplat)

# Getting Started
## Quick Start
Copy and paste code below in an index.html file or remix in the Web Playground


<style> body {margin: 0;} </style>
<script type="importmap">
  {
    "imports": {
      "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.174.0/three.module.js",
      "@forge-gfx/forge": "https://forge.dev/releases/forge/0.1.0/forge.module.js"
    }
  }
</script>
<script type="module">
  import * as THREE from "three";
  import { SplatMesh } from "@forge-gfx/forge";

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement)

  const splatURL = "https://forge.dev/assets/splats/butterfly.spz";
  const butterfly = new SplatMesh({ url: splatURL });
  butterfly.quaternion.set(1, 0, 0, 0);
  butterfly.position.set(0, 0, -3);
  scene.add(butterfly);

  renderer.setAnimationLoop(function animate(time) {
    renderer.render(scene, camera);
    butterfly.rotation.y += 0.01;
  });
</script>

## Install with NPM

npm install @forge-gfx/forge

## Develop and contribute to Forge
Build Forge (It requires Rust installed in your machine)


npm install
npm run dev
This will run a Web server at http://localhost:8080/ with the examples.

## Table of Contents
Forge Overview
System Design
ForgeRenderer
ForgeViewpoint
SplatMesh
PackedSplats
Loading Gsplats
Procedural Splats
Splat RGBA-XYZ SDF editing
Dyno overview
Dyno standard library
Controls
Performance tuning
Community Resources

Forge aims to expand what's possible with Gaussian Splatting and help 3D/4D creators bring their visions to life and share it with others.

# Overview
3D Gaussian Splatting has emerged as a frontrunner in generative AI and 3D reconstruction. By representing 3D scenes and objects as collections of tiny oriented Gaussian-shaped blobs (aka "splats"), machine learning techniques can be used to create detailed, photorealistic 3D content that can be rendered in real-time. However, 3DGS is a relatively new technique that that can't be used in many traditional triangle-based 3D mesh rendering engines. Tools for creating, editing, and rendering 3DGS are in their infancy, mostly able to only work with a single, static 3DGS object at time.

The web's most popular 3D graphics library THREE.js, can't render 3DGS directly. Although libraries exist to render 3DGS on the web, they each come with different limitations and don't treat 3DGS objects as first-class citizens in the scene hierarchy. Limitations include: rendering only one 3DGS object at time, incorrect occlusion between 3DGS objects, inability to dynamically modify the objects, requiring WebGPU, or slow/laggy rendering. We believe 3DGS will play an important role in future 3D/4D content creation, and we built Forge to make it easy to incorporate 3DGS into online experiences.

## Forge
Forge is a dynamic 3DGS renderer built for THREE.js and WebGL2 that runs in any web browser (desktop, mobile, and WebXR). With a handful of lines of code, anyone using THREE.js can easily add 3DGS to their scenes (even by vibe coding!). By creating one or more SplatMesh objects and adding them to your scene, Forge will render these alongside traditional triangle-based meshes during your regular render(scene, camera) call. SplatMesh derives from THREE.Object3D and can be translated and rotated like any other object, placed arbitrarily in the scene hierarchy, and animated by adjusting the values each frame. A SplatMesh can be created from most splat file formats via the url parameter or by directly creating the splats one by one.

3DGS is still in its infancy, and we expect new techniques will be developed for recoloring/relighting, animation, transitions, and other creative or interactive effects. We designed Forge to be a programmable splat engine from the ground up, giving you unprecedented control over how individual splats are generated, animated, and rendered into the scene. Similar to shader graph systems in modern 3D graphics engines, Forge allows you to compose blocks of functions (called Dynos) into computation graphs that can generate splats procedurally, modify them arbitrarily, or anything other computation you can imagine, and will be converted to GLSL to run on the GPU.

## Features
Integrates with THREE.js rendering pipeline to fuse splat and mesh-based objects
Portable: Works across almost all devices, targeting 98%+ WebGL2 support
Renders fast even on low-powered mobile devices
Render multiple splat objects together with correct sorting
Most major splat file formats supported including .PLY (also compressed), .SPZ, .SPLAT, .KSPLAT
Render multiple viewpoints simultaneously
Fully dynamic: each splat can be transformed and edited for animation
Real-time splat color editing, displacement, and skeletal animation
Shader graph system to dynamically create/edit splats on the GPU

# System Design
One of the biggest challenges in real-time Gaussian splat rendering is sorting the splats so that they can be drawn and blended in back-to-front order, known as the Painter's algorithm.

## Rendering data flow cycle
ForgeRenderer is a key component in Forge that manages this process. It traverses the visible THREE.js scene graph and compiles a complete list of all splats across the scene, generated by instances of SplatMesh in the scene hierarchy.

Each ForgeRenderer has a default ForgeViewpoint that reads back a list of all splat viewpoint distances from the GPU, then determines the splat draw order using an efficient bucket sort algorithm, run in a background worker thread via SplatWorker. You can spawn additional ForgeViewpoints to create multiple simultaneous render viewpoints.

Finally, on the next THREE.js render() call, ForgeRenderer invokes a single instanced geometry draw call to draw all the scene's splats in the correct back-to-front order, merging with other opaque THREE.js geometry using the Z buffer. The sort order lags the render by at least one frame, but possibly more on older devices, but is not usually perceptible.


// Optionally add a ForgeRenderer to the scene to manage SplatMesh rendering.
// If none is created, Forge will create one for you automatically.
const forge = new ForgeRenderer({ renderer: webGlRenderer });
scene.add(forge);
This design allows splats from distinct objects/scenes to coexist in space and sort correctly w.r.t. each other's splats. Splats from independent SplatMeshes are aggregated using a SplatAccumulator, which produces a PackedSplats, a collection splats stored in a cache-efficient 16-byte/splat format.

## "Programmable Splats"
Forge also uses this opportunity to run a user-programmable data pipeline on each splat on the GPU. The standard pipeline provides high-level functionality, such as applying rigid transforms, adjusting RGB / opacity, and spherical harmonics, but also color editing and perturbations (via SplatEdit) and a dual-quaternion skeletal animation system (SplatSkinning). The standard pipeline also allows injecting arbitrary code to modify each splat via dyno shader graph system.

SplatMesh derives from a more general base class SplatGenerator, which itself derives from THREE.Object3D. As such, it can be placed anywhere in the scene hierarchy and obeys expected local and global coordinate transforms. A SplatGenerator is the most general form of a "splat object", whose splats are produced programmatically via a dyno shader graph function that maps { index: "int" } to { gsplat: "Gsplat" }. A SplatMesh is a higher-level object that implements such a mapping, reading source splats from a template (loaded via a url constructor parameter or otherwise) at the given index, then applying functions such as transforming to world space.

In contrast, implementing a SplatGenerator gives you full control to write any function that programmatically computes a splat's attributes (center, scales, quaternion, rgba). These could be stateless (relying only on index, random-number generators, etc), or could rely on a complex combination of splat files, textures, and other global parameters for real-time procedural generation, and can vary with time to produce real-time animations.

The dyno shader graph system allows you to create these programmatic pipelines with Javascript code, which is synthesized into GLSL code and compiled and run on the GPU. This dyno system powers other components of Forge as well, such as Readback (which can perform any computation and read back the resulting value), used to compute the sort distance metric for pairs of splats and read them back for CPU sorting.

# ForgeRenderer
## Optionally adding to your THREE.Scene
Forge internally uses a ForgeRenderer object in your THREE.Scene to perform splat rendering. Forge will automatically create a ForgeRenderer and add it to your scene if you don't create one yourself. For more advanced use cases such as multiple viewpoints or rendering environment maps, you can create your own ForgeRenderer and add it anywhere in the scene, for example at the root:


const forge = new ForgeRenderer({
  renderer: myThreeJsWebGlRenderer,
});
const scene = new THREE.Scene();
scene.add(forge);

## Larger scenes
All scene splats are accumulated by SplatAccumulator into a single global PackedSplats, whose coordinates are relative to the ForgeRenderer's origin. Splats that are far away from this origin may exhibit float16 quantization artifacts, so if you plan on moving the camera large distances you can instead add ForgeRenderer as a child of your THREE.Camera, ensuring that coordinates will have higher precision near the camera viewpoint:


const aspect = canvas.width / canvas.height;
const camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
scene.add(camera);
// Add ForgeRenderer as a child of camera to follow it
camera.add(forge);

## Creating a ForgeRenderer

const forge = new ForgeRenderer({
  renderer: THREE.WebGLRenderer;
  clock?: THREE.Clock;
  autoUpdate?: boolean;
  preUpdate?: boolean;
  originDistance?: number;
  maxStdDev?: number;
  enable2DGS?: boolean;
  preBlurAmount?: number;
  blurAmount?: number;
  falloff?: number;
  clipXY?: number;
  view?: ForgeViewpointOptions;
});

### Required parameters
Parameter	Description
renderer	Pass in your THREE.WebGLRenderer instance so Forge can perform work outside the usual render loop. Should be created with antialias: false (default setting) as WebGL anti-aliasing doesn't improve Gaussian Splatting rendering and significantly reduces performance.
Optional parameters
Parameter	Description
clock	Pass in a THREE.Clock to synchronize time-based effects across different systems. Alternatively, you can set the ForgeRenderer properties time and deltaTime directly. (default: new THREE.Clock)
autoUpdate	Controls whether to check and automatically update splat collection after each frame render. (default: true)
preUpdate	Controls whether to update the splats before or after rendering. For WebXR this must be false in order to complete rendering as soon as possible. (default: false)
originDistance	Distance threshold for ForgeRenderer movement triggering a splat update at the new origin. (default: 1.0) This can be useful when your ForgeRenderer is a child of your camera and you want to retain high precision coordinates near the camera.
maxStdDev	Maximum standard deviations from the center to render Gaussians. Values Math.sqrt(5)..Math.sqrt(9) produce good results and can be tweaked for performance. (default: Math.sqrt(8))
enable2DGS	Enable 2D Gaussian splatting rendering ability. When this mode is enabled, any scale x/y/z component that is exactly 0 (minimum quantized value) results in the other two non-zero axes being interpreted as an oriented 2D Gaussian Splat instead of the usual approximate projected 3DGS Z-slice. When reading PLY files, scale values less than e^-20 will be interpreted as 0. (default: true)
preBlurAmount	Scalar value to add to 2D splat covariance diagonal, effectively blurring + enlarging splats. In scenes trained without the splat anti-aliasing tweak this value was typically 0.3, but with anti-aliasing it is 0.0 (default: 0.0)
blurAmount	Scalar value to add to 2D splat covariance diagonal, with opacity adjustment to correctly account for "blurring" when anti-aliasing. Typically 0.3 (equivalent to approx 0.5 pixel radius) in scenes trained with anti-aliasing.
falloff	Modulate Gaussian kernel falloff. 0 means "no falloff, flat shading", while 1 is the normal Gaussian kernel. (default: 1.0)
clipXY	X/Y clipping boundary factor for splat centers against view frustum. 1.0 clips any centers that are exactly out of bounds (but the splat's entire projection may still be in bounds), while 1.4 clips centers that are 40% beyond the bounds. (default: 1.4)
view	Configures the ForgeViewpointOptions for the default ForgeViewpoint associated with this ForgeRenderer. Notable option: sortRadial (sort by radial distance or Z-depth)

## newViewpoint(options: ForgeViewpointOptions)
Create a new ForgeViewpoint for this ForgeRenderer. Note that every ForgeRenderer has an initial forge.defaultView: ForgeViewpoint created during construction, which is used for default canvas rendering. Calling this method allows you to create additional viewpoints, which can be updated automatically each frame (performing splat sorting every time there is an update), or updated on-demand for controlled rendering for video frame rendering or similar applications.

## update({ scene })
If forge.autoUpdate is false then you must manually call forge.update({ scene }) to have the scene splats re-generated.

## renderEnvMap({ renderer, scene, worldCenter, ... })
Renders out the scene to an environment map that can be used for image-based lighting or similar applications. First updates splats, sorts them with respect to the provided worldCenter, renders 6 cube faces, then pre-filters them using THREE.PMREMGenerator and returns a THREE.Texture that can assigned directly to a THREE.MeshStandardMaterial.envMap property.

## recurseSetEnvMap(root, envMap)
Utility function to recursively set the envMap property for any THREE.MeshStandardMaterial within the subtree of root.

## getRgba({ generator, ... })
Utility function that helps extract the splat RGBA values from a SplatGenerator, including the result of any real-time RGBA SDF edits applied to a SplatMesh. This effectively "bakes" any computed RGBA values, which can now be used as a pipeline input via SplatMesh.splatRgba to inject these baked values into the splat data.

## readRgba({ generator, ...})
Utility function that builds on getRgba({ generator }) and additionally reads back the RGBA values to the CPU in a Uint8Array with packed RGBA in that byte order.

# ForgeViewpoint
A ForgeViewpoint is created from and tied to a ForgeRenderer, and represents an independent viewpoint of all the scene splats and their sort order. Making these viewpoints explicit allows us to have multiple, simultaneous viewpoint renders, for example for camera preview panes or overhead map views.

When creating a ForgeRenderer it automatically creates a default viewpoint .defaultView that is used in the normal render loop when drawing to the canvas, and is automatically updated whenever the camera moves. Additional viewpoints can be created and configured separately:

## Creating a ForgeViewpoint

const viewpoint = forge.newViewpoint({
  autoUpdate?: boolean;
  camera?: THREE.Camera;
  viewToWorld?: THREE.Matrix4;
  target?: {
    width: number;
    height: number;
    doubleBuffer?: boolean;
    superXY?: number;
  };
  onTextureUpdated?: (texture: THREE.Texture) => void;
  sortRadial?: boolean;
  sortDistance?: number;
  sortCoorient?: boolean;
  depthBias?: number;
  sort360?: boolean;
});

### Optional parameters
Parameter	Description
autoUpdate	Controls whether to auto-update its sort order whenever the ForgeRenderer updates the splats. If you expect to render/display from this viewpoint most frames, set this to true. (default: false)
camera	Set a THREE.Camera for this viewpoint to follow. (default: undefined)
viewToWorld	Set an explicit view-to-world transformation matrix for this viewpoint (equivalent to camera.matrixWorld), overrides any camera setting. (default: undefined)
target	Configure viewpoint with an off-screen render target. (default: undefined)
target.width	Width of the render target in pixels.
target.height	Height of the render target in pixels.
target.doubleBuffer	If you want to be able to render a scene that depends on this target's output (for example, a recursive viewport), set this to true to enable double buffering. (default: false)
target.superXY	Super-sampling factor for the render target. Values 1-4 are supported. Note that re-sampling back down to .width x .height is done on the CPU with simple averaging only when calling readTarget(). (default: 1)
onTextureUpdated	Callback function that is called when the render target texture is updated. Receives the texture as a parameter. Use this to update a viewport with the latest viewpoint render each frame. (default: undefined)
sortRadial	Whether to sort splats radially (geometric distance) from the viewpoint (true) or by Z-depth (false). Most scenes are trained with the Z-depth sort metric and will render more accurately at certain viewpoints. However, radial sorting is more stable under viewpoint rotations. (default: true)
sortDistance	Distance threshold for re-sorting splats. If the viewpoint moves more than this distance, splats will be re-sorted. (default: 0.01 units)
sortCoorient	View direction dot product threshold for re-sorting splats. For sortRadial: true it defaults to 0.99 while sortRadial: false uses 0.999 because it is more sensitive to view direction. (default: 0.99 if sortRadial else 0.999)
depthBias	Constant added to Z-depth to bias values into the positive range for sortRadial: false, but also used for culling splats "well behind" the viewpoint origin (default: 1.0)
sort360	Set this to true if rendering a 360 to disable "behind the viewpoint" culling during sorting. This is set automatically when rendering 360 envMaps using the ForgeRenderer.renderEnvMap() utility function. (default: false)

## dispose()
Call this when you are done with the ForgeViewpoint and want to free up its resources (GPU targets, pixel buffers, etc.)

## setAutoUpdate(autoUpdate: boolean)
Use this function to change whether this viewpoint will auto-update its sort order whenever the attached ForgeRenderer updates the splats. Turn this on or off depending on whether you expect to do renders from this viewpoint for most frames.

## async prepareRenderPixels({ scene, camera?, viewToWorld?, update?, forceOrigin? })
Render out a viewpoint as a Uint8Array of RGBA values for the provided scene and any camera/viewToWorld viewpoint overrides. By default update is true, which triggers its ForgeRenderer to check and potentially update the splats. Setting update to false disables this and sorts the splats as they are. Setting forceOrigin (default: false) to true forces the view update to recalculate the splats with this view origin, potentially altering any view-dependent effects. If you expect view-dependent effects to play a role in the rendering quality, enable this.

Underneath, prepareRenderPixels() simply calls await this.prepare(...), this.renderTarget(...), and finally returns the result of this.readTarget(), a Promise to a Uint8Array with RGBA values for all the pixels (potentially downsampled if the superXY parameter was used). These steps can also be called manually, for example if you need to alter the scene before and after this.renderTarget(...) to hide UI elements from being rendered.

## async prepare({ scene, camera?, viewToWorld?, update?, forceOrigin? })
See above async prepareRenderPixels() for explanation of parameters. Awaiting this method updates the splats in the scene and performs a sort of the splats from this viewpoint, preparing it for a subsequent this.renderTarget() call in the same tick.

## renderTarget({ scene, camera? })
Render out the viewpoint to the view target RGBA buffer. Swaps buffers if doubleBuffer: true was set. Calls onTextureUpdated(texture) with the resulting texture.

## async readTarget()
Read back the previously rendered target image as a Uint8Array of packed RGBA values (in that order). If superXY was set greater than 1 than downsampling is performed in the target pixel array with simple averaging to derive the returned pixel values. Subsequent calls to this.readTarget() will reuse the same buffers to minimize memory allocations.

## autoPoll()
This is called automatically by ForgeRenderer, there is no need to call it! The method cannot be private because then ForgeRenderer would not be able to call it.

## ForgeViewpoint.EMPTY_TEXTURE
If you need an empty THREE.Texture to use to initialize a uniform that is updated via onTextureUpdated(texture), this static texture can be handy.

# SplatMesh
A SplatMesh is a high-level interface for displaying and manipulating a "Splat mesh", a collection of Gaussian splats that serves as an object of sorts. It is analagous to a traditional triangle-based THREE.Mesh, which consists of geometry (points and triangles) and materials (color and lighting). Similarly, a SplatMesh contains geometry (splat centers, orientation, and xyz scales) and materials (RGB color, opacity, spherical harmonics), and can be added anywhere in the scene hierarchy.

The usual THREE.js properties position, quaternion, rotation behave as you would expect, however scale only allows uniform scaling and averages the x/y/z scales. Additional properties recolor and opacity are multiplied in with the final splat color and opacity.

SplatMesh is a subclass of the more fundamental SplatGenerator, which itself is a subclass of THREE.Object3D. Any methods and properties on Object3D are also available in SplatMesh. SplatGenerator gives you more control over splat generation and modification, but SplatMesh has an simpler higher-level API.

## Creating a SplatMesh

const splats = new SplatMesh({
  // Fetch PLY/SPZ/SPLAT/KSPLAT file from URL
  url?: string;
  // Decode raw PLY/SPZ/SPLAT/KSPLAT file bytes
  fileBytes?: Uint8Array | ArrayBuffer;
  // Override file type
  fileType?: SplatFileType;
  // Use PackedSplats object as source
  packedSplats?: PackedSplats;
  // Reserve space for at least this many splats for construction
  maxSplats?: number;
  // Constructor callback to create splats
  constructSplats?: (splats: PackedSplats) => Promise<void> | void;
  // Callback for when mesh initialization is complete
  onLoad?: (mesh: SplatMesh) => Promise<void> | void;
  // Toggle controls whether SplatEdits have an effect, default true
  editable?: boolean;
  // Frame callback to update mesh. Call mesh.updateVersion() if we need to re-generate
  onFrame?: ({
    mesh,
    time,
    deltaTime,
  }: { mesh: SplatMesh; time: number; deltaTime: number }) => void;
  // Object-space and world-space splat modifiers to apply
  objectModifier?: GsplatModifier;
  worldModifier?: GsplatModifier;
});
// Add to scene to show splats
scene.add(splats);

### Optional parameters
You can create a new SplatMesh() with no options, which will create a new default instance with .numSplats=0. Alternatively, you can provide an input url to fetch and decode, fileBytes, or packedSplats (an existing collection of "packed" splats). Forge supports most splat file types, including .ply (including SuperSplat compressed), .splat, .ksplat, .spz. To load filetypes .splat and .ksplat (which can't be reliably auto-detected), use the optional fileType argument.

Constructor argument callbacks can be used like constructSplats to create a collection of splats procedurally at initialization, onLoad when loading and initialization completes, onFrame to update state every frame. Splat effects can be injected into the standard splat processing pipeline that operate in object-space and world-space via objectModifier and worldModifier respectively.

Parameter	Description
url	URL to fetch a Gaussian splat file from (supports .ply, .splat, .ksplat, .spz formats). (default: undefined)
fileBytes	Raw bytes of a Gaussian splat file to decode directly instead of fetching from URL. (default: undefined)
fileType	Override the file type detection for formats that can't be reliably auto-detected (.splat, .ksplat). (default: undefined auto-detects other formats from file contents)
packedSplats	Use an existing PackedSplats object as the source instead of loading from a file. Can be used to share a collection of splats among multiple SplatMeshes (default: undefined creates a new empty PackedSplats or decoded from a data source above)
maxSplats	Reserve space for at least this many splats when constructing the mesh initially. (default: determined by file)
constructSplats	Callback function to programmatically create splats at initialization in a newly created PackedSplats. (default: undefined)
onLoad	Callback function that is called when mesh initialization is complete. (default: undefined)
editable	Controls whether SplatEdits have any effect on this mesh. (default: true)
onFrame	Callback function that is called every frame to update the mesh. Call mesh.updateVersion() if splats need to be regenerated due to some change. Calling updateVersion() is not necessary for object transformations, recoloring, or opacity adjustments as these changes are auto-detected. (default: undefined)
objectModifier	Splat modifier to apply in object-space before any transformations. A GsplatModifier is a dyno shader-graph block that transforms an input gsplat: DynoVal<Gsplat> to an output gsplat: DynoVal<Gsplat> with gsplat.center and other parameters in object-space. (default: undefined)
worldModifier	Splat modifier to apply in world-space after transformations. (default: undefined)

## Instance properties
The constructor argument options packedSplats, editable, onFrame, objectModifier, and worldModifier can be modified directly on the SplatMesh.

If you modify packedSplats you should set splatMesh.packedSplats.needsUpdate = true to signal to THREE.js that it should re-upload the data to the underlying texture. Use this sparingly with objects with lower splat counts as it requires a CPU-GPU data transfer for each frame. Thousands to tens of thousands of splats is reasonable. (See hands.ts for an example of rendering "splat hands" in WebXR using this technique.)

If you modify objectModifier or worldModifier you should call splatMesh.updateGenerator() to update the pipeline and have it compile to run efficiently on the GPU.

Additional properties on a SplatMesh instance:

Property	Description
initialized	A Promise<SplatMesh> you can await to ensure fetching, parsing, and initialization has completed
isInitialized	A boolean indicating whether initialization is complete
recolor	A THREE.Color that can be used to tint all splats in the mesh. (default: new THREE.Color(1, 1, 1))
opacity	Global opacity multiplier for all splats in the mesh. (default: 1)
context	A SplatMeshContext consisting of useful scene and object dyno uniforms that can be used to in the splat processing pipeline, for example via objectModifier and worldModifier. (created on construction)
enableViewToObject	Set to true to have the viewToObject property in context be updated each frame. If the mesh has extra.sh1 (first order spherical harmonics directional lighting) this property will always be updated. (default: false )
enableViewToWorld	Set to true to have context.viewToWorld updated each frame. (default: false)
enableWorldToView	Set to true to have context.worldToView updated each frame. (default: false)
skinning	Optional SplatSkinning instance for animating splats with dual-quaternion skeletal animation. (default: null)
edits	Optional list of SplatEdits to apply to the mesh. If null, any SplatEdit children in the scene graph will be added automatically. (default: null)
splatRgba	Optional RgbaArray to overwrite splat RGBA values with custom values. Useful for "baking" RGB and opacity edits into the SplatMesh. (default: null)
maxSh	Maximum Spherical Harmonics level to use. Forge supports up to SH3. Call updateGenerator() after changing. (default: 3)

## dispose()
Call this when you are finished with the SplatMesh and want to free any buffers it holds (via packedSplats).

## pushSplat(center, scales, quaternion, opacity, color)
Creates a new splat with the provided parameters (all values in "float" space, i.e. 0-1 for opacity and color) and adds it to the end of the packedSplats, increasing numSplats by 1. If necessary, reallocates the buffer with an exponential doubling strategy to fit the new data, so it's fairly efficient to pushSplat(...) each splat you want to create in a loop.

## forEachSplat(callback: (index, center, scales, quaternion, opacity, color) => void)
This method iterates over all splats in this instance's packedSplats, invoking the provided callback with index: number in 0..=(this.numSplats-1), center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion, opacity: number (0..1), and color: THREE.Color (rgb values in 0..1). Note that the objects passed in as center etc. are the same for every callback invocation: they are reused for efficiency. Changing these values has no effect as they are decoded/unpacked copies of the underlying data. To update the packedSplats, call .packedSplats.setSplat(index, center, scales, quaternion, opacity, color).

## updateGenerator()
Call this whenever something changes in the splat processing pipeline, for example changing maxSh or updating objectModifier or worldModifier. Compiled generators are cached for efficiency and re-used when the same graph structure emerges after successive changes.

## update(...)
This is called automatically by ForgeRenderer and you should not have to call it. It updates parameters for the generated pipeline and calls updateGenerator() if the pipeline needs to change.

## raycast(raycaster, intersects: { distance, point, object}[])
This method conforms to the standard THREE.Raycaster API, performing object-ray intersections using this method to populate the provided intersects[] array with each intersection point's distance: number, point: THREE.Vector3, and object: SplatMesh. Note that this method is synchronous and uses a WebAssembly-based ray-splat intersection algorithm that iterates over all points. Raycasting against millions of splats have a noticeable delay, and should not be called every frame.

Usage example:


const raycaster = new THREE.Raycaster();
canvas.addEventListener("click", (event) => {
  raycaster.setFromCamera(new THREE.Vector2(
    (event.clientX / canvas.width) * 2 - 1,
    -(event.clientY / canvas.height) * 2 + 1,
  ), camera);
  const intersects = raycaster.intersectObjects(scene.children);
  const splatIndex = intersects.findIndex((i) => i.object instanceof SplatMesh);
});

# PackedSplats
A PackedSplats is a collection of Gaussian splats, packed into a format that takes exactly 16 bytes per splat to maximize memory and cache efficiency. The center xyz coordinates are encoded as float16 (3 x 2 bytes), scale xyz as 3 x uint8 that encode a log scale from e^-9 to e^9, rgba as 4 x uint8, and quaternion encoded via axis+angle using 2 x uint8 for octahedral encoding of the axis direction and a uint8 to encode rotation amount from 0..Pi.

## Creating a PackedSplats

const packedSplats = new PackedSplats({
  // Fetch PLY/SPZ/SPLAT/KSPLAT file from URL
  url?: string;
  // Decode raw PLY/SPZ/SPLAT/KSPLAT file bytes
  fileBytes?: Uint8Array | ArrayBuffer;
  // Override file type
  fileType?: SplatFileType;
  // Reserve space for at least this many splats for construction
  maxSplats?: number;
  // Use provided packed data array, 4 words per splat
  packedArray?: Uint32Array;
  // Override number of splats in packed array to a subset
  numSplats?: number;
  // Constructor callback to create splats
  construct?: (splats: PackedSplats) => Promise<void> | void;
  // Extra splat data, such as sh1..3 components
  extra?: Record<string, unknown>;
});

### Optional parameters
Like for SplatMesh you can create a new PackedSplats() with no options, which will create a new empty instance with 0 splats. Similarly, you can provide an input url or fileBytes to decode from a file source. You can also create a PackedSplats from a raw Uint32Array where each successive 4 Uint32 values encodes one "packed" splat. Finally, a construct(splats) callback provides an ergonomic way to create splats procedurally with an in-line initialization closure.

Parameter	Description
url	URL to fetch a Gaussian splat file from (supports .ply, .splat, .ksplat, .spz formats). (default: undefined)
fileBytes	Raw bytes of a Gaussian splat file to decode directly instead of fetching from URL. (default: undefined)
fileType	Override the file type detection for formats that can't be reliably auto-detected (.splat, .ksplat). (default: undefined auto-detects other formats from file contents)
maxSplats	Reserve space for at least this many splats when constructing the collection initially. The array will automatically resize past maxSplats so setting it is an optional optimization. (default: 0)
packedArray	Use provided packed data array, where each 4 consecutive uint32 values encode one "packed" splat. (default: undefined)
numSplats	Override number of splats in packed array to use only a subset. (default: length of packed array / 4)
construct	Callback function to programmatically create splats at initialization. (default: undefined)
extra	Additional splat data, such as spherical harmonics components (sh1, sh2, sh3). (default: {})

## Encoding / Decoding
Utility functions are provided in Javascript to pack/unpack these encodings:


// Set via packedSplats interface
packedSplats.setSplat(index, center, scales, quaternion, opacity, color);

// Set underlying Uint32 array directly
import { utils } from "@forge-gfx/forge";
utils.setPackedSplat(packedSplats.packedArray, index, x, y, z, scaleX, scaleY, ...);

// Set rotation components of underlying Uint32 array directly
utils.setPackedSplatQuat(packedSplats.packedArray, index, quatX, quatY, quatZ, quatW);

// Unpack all splat components from the Uint32 array
const { center, scales, quaternion, color, opacity } = utils.unpackSplat(packedSplats.packedArray, index);

// Unpack all splats with callback
packedSplats.forEachSplat((index, center, scales, quaternion, opacity, color) => {
    // Use unpacked splat data. Changing the inputs directly has no effect.
    // Update just the scales component
    utils.setPackedSplatScales(packedSplat.packedArray, index, 0.005, 0.01, 0.015);
    // Update the entire splat
    packedSplat.setSplat(index, center, scales, quaternion, opacity, color);
});
In GLSL code you can use the following utility functions that are available via splatDefines.glsl, which is included in all GLSL shader programs:


// Pack a splat into a uvec4
uvec4 packSplat(vec3 center, vec3 scales, vec4 quaternion, vec4 rgba);

// Unpack a splat from a uvec4
void unpackSplat(uvec4 packed, out vec3 center, out vec3 scales, out vec4 quaternion, out vec4 rgba);
In dyno shader contexts you can read and unpack a splat from a PackedSplats:


// Fetch and unpack a particular index from a PackedSplats.
const gsplat = dyno.readPackedSplat(packedSplats.dyno, index);

### Byte Layout
Each PackedSplat occupies 16 bytes (4 × uint32), with the following layout of fields by byte offset:

Offset (bytes)	Field	Size (bytes)	Description
0	R	1	Red color channel (uint8 0–255 → 0.0–1.0)
1	G	1	Green color channel (uint8 0–255 → 0.0–1.0)
2	B	1	Blue color channel (uint8 0–255 → 0.0–1.0)
3	A	1	Alpha (opacity) channel (uint8 0–255 → 0.0–1.0)
4–5	center.x	2	X coordinate of splat center (float16)
6–7	center.y	2	Y coordinate of splat center (float16)
8–9	center.z	2	Z coordinate of splat center (float16)
10	quat oct.U	1	Octahedral quaternion U component (uint8)
11	quat oct.V	1	Octahedral quaternion V component (uint8)
12	scale.x	1	X scale, log-encoded to uint8
13	scale.y	1	Y scale, log-encoded to uint8
14	scale.z	1	Z scale, log-encoded to uint8
15	quat angle (θ)	1	Encoded quaternion rotation angle (uint8, θ/π·255)

### Splat RGBA encoding
RGB values are encoded are uint8 sRGB values with 0..255 mapping to 0..1. When loading from a PLY file these values are derived by calculating ply[f_dc_0] * SH_C0 + 0.5.

Opacity is encoded on a linear scale where 0..255 maps to 0..1.

### Splat center encoding
The center x/y/z components are encoded as float16, which provides 10 bits of mantissa, or approximately 1K steps (0.1%) of resolution between each successive power of 0 from the origin, with a range of up to 32K in distance. If most of the splats are positioned relative to the origin this provides enough positional resolution. Splats that are transformed far from the origin, however (for example when bringing multiple SplatMeshes together in a scene that are far apart) may lose precision when mapped to the space of ForgeRenderer. For scenes where the user camera may move far from the origin, you may want to tie the ForgeRenderer origin to your camera by adding it as a child of the camera.

### Splat scales encoding
The XYZ scales are encoded independently using the following mapping: Any scale values below e^-20 are interpreted as "true zero" scale, and encoded as uint8(0). Any other values quantized by computing ln(scale_xyz), mapping the range e^-9..e^9 to uint8 values 1..255, rounding, and clamping. This logarithmic scale range can encode values from 0.0001 up to 8K in scale, with approximately 7% steps between discrete sizes, and has minimal impact on perceptible visual quality.

### Splat orientation encoding
We encode a splat's quaternion/orientation by encoding it explicitly in an axis + angle representation: 8 bits for each U/V coordinate for octahedral encoding of the axis direction, and 8 bits to encode the rotation angle range 0..Pi.

This representation was chosen over other internal rotation representations because it provides a good mix of speed/simplicity, uniformity of representable orientations, and especially its ability to handle rotations "near identity". Other encodings such as the more common "3 quaternion components" tend to have poor rotational resolution around I(1), which is a particularly important regime of this parameter.

### extra splat data
Each instance of PackedSplats also has a property extra: Record<string, unknown> that is used to attach additional splat-related data to the PackedSplats container. For example, spherical harmonics degrees 1..3 are stored in sh1: Uint32Array(numSplats * 2), sh2: Uint32Array(numSplats * 4), sh3: Uint32Array(numSplats * 4), and intermediate textures are generated by SplatMesh and stored as sh1Texture etc.

This structure can be used to extend and store additional data in a PackedSplats, but there is no specific convention yet to prevent collisions.

sh1 stores each of 3 x 3 RGB signed components as Sint7 (mapping -1..1) in 63 bits (8 bytes) per splat. sh2 stores each of 5 x 3 RGB signed components as Sint8 in 120 bits (16 bytes). sh3 stores each of 7 x 3 RGB signed components as Sint6 in 126 bits (16 bytes) to improve memory bandwidth efficiency. Note that using spherical harmonics dramatically increases the memory footprint from 16 bytes per splat up to 56 bytes per splat with SH0..3, which can impact rendering performance.

## PackedSplats instance methods

### dispose()
Call this when you are finished with the PackedSplats and want to free any render targets + textures it holds.

### ensureSplats(numSplats)
Ensures that this.packedArray can fit numSplats splats. If it's too small, resize exponentially and copy over the original data.

Typically you don't need to call this, because calling this.setSplat(index, ...) and this.pushSplat(...) will automatically call ensureSplats() so we have enough splats.

### getSplat(index): { center, scales, quaternion, opacity, color }
Unpack the 16-byte splat data at index into the THREE.js components center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion, opacity: number 0..1, color: THREE.Color 0..1.

### setSplat(index, center, scales, quaternion, opacity, color)
Set all PackedSplat components at index with the provided splat attributes (can be the same objects returned by getSplat). Ensures there is capacity for at least index+1 splats.

### pushSplat(center, scales, quaternion, opacity, color)
Effectively calls this.setSplat(this.numSplats++, center, ...), useful on construction where you just want to iterate and create a collection of splats.

### forEachSplat(callback: (index, center, scales, quaternion, opacity, color) => void)
Iterate over splats index 0..=(this.numSplats-1), unpack each splat and invoke the callback function with the splat attributes.

### getTexture()
Returns a THREE.DataArrayTexture representing the PackedSplats content as a Uint32x4 data array texture (2048 x 2048 x depth in size)

### getEmpty()
Can be used where you need an uninitialized THREE.DataArrayTexture like a uniform you will update with the result of this.getTexture() later.

## Generating splats on the GPU
To generate a large number of splats we can use the dyno shader graph system, which allows you to create a computation graph mapping { index: DynoVal<"int"> } to { gsplat: DynoVal<Gsplat> } via Javascript code, then have that synthesize GLSL code, which is finally compiled and executed in parallel on the GPU.

This building block is used by ForgeRenderer to traverse each visible SplatMesh/SplatGenerator and have it "generate" its splats into the global PackedSplats array managed by a SplatAccumulator. At its core a PackedSplats has the ability to run dyno computation graphs to produce its contents using the following methods, which are typically managed by ForgeRenderer:

### generateMapping(splatCounts: number[]): { maxSplats, mapping[] }
Given an array of splatCounts (.numSplats for each SplatGenerator/SplatMesh in the scene), compute a "mapping layout" in the composite array of generated outputs.

### ensureGenerate(maxSplats)
Ensures our PackedSplats.target render target has enough space to generate maxSplats total splats, and reallocate if not large enough.

### generate({ generator, base, count, ... })
Executes a dyno program specified by generator which is any DynoBlock that maps { index: "int" } to { gsplat: Gsplat }. This is invoked from ForgeRenderer.updateInternal() to re-generate splats in the scene for SplatGenerator instances whose version is newer than last generated version.

## Using dynamic PackedSplats inputs in dyno
You can use a PackedSplats in a dyno block using the function dyno.readPackedSplats(packedSplats.dyno, dynoIndex) where dynoIndex is of type DynoVal<"int"> If you need to be able to change the input PackedSplats dynamically, however, you should create a DynoPackedSplats, whose property packedSplats you can set to any PackedSplats, which will be used in the next dyno shader program execution.

# Loading Splats
Forge provides loaders for most popular splat file formats, including .ply (original "gsplat" format, compressed SuperSplat variant, and plain x/y/z/r/g/b point clouds) and .spz (Niantic open source compressed format), both auto-detected from the file contents.

Forge can also load formats .splat (from antimatter15/splat) and .ksplat (from mkkellogg/GaussianSplats3D) if the file type can be inferred from the URL/path extension, or set explicitly using the fileType property when creating a SplatMesh or PackedSplats.

## Loading auto-detectable formats .ply and .spz
Adding an individual SplatMesh from an auto-detectable format is easy and can be done as simply as:


// Load and create SplatMesh in one go
const splats = new SplatMesh({ url: "./butterfly.ply" });
scene.add(splats);

// No file extension but we can auto-detect format from the contents
scene.add(new SplatMesh({ url: "plyBin/0123456789abcdef" }));
scene.add(new SplatMesh({ url: "spzBin/fedcba9876543210" }));

### Load via PackedSplats
Alternatively, you can load a .ply or .spz into a PackedSplats, which can then be used as an input source for multiple SplatMesh instances in the scene.


const packedSplats = new PackedSplats({ url: "./clone.ply" });

const splats1 = new SplatMesh({ packedSplats });
scene.add(splats1);

const splats2 = new SplatMesh({ packedSplats });
scene.add(splats2);

### Load via SplatLoader
Finally, you can make use of the THREE.Loader infrastructure via the SplatLoader class. A Loader has a synchronous and asynchronous interface. You can provide progress meters during downloads and invoke completion callbacks as follows:


const loader = new SplatLoader();
loader.loadAsync(url, (event) => {
  if (event.type === "progress") {
    const progress = event.lengthComputable
      ? `${((event.loaded / event.total) * 100).toFixed(2)}%`
      : `${event.loaded} bytes`;
    console.log(`Background download progress: ${progress}`);
  }
})
.then((packedSplats) => {
  const splatMesh = new SplatMesh({ packedSplats });
  // Re-orient from OpenCV to OpenGL coordinates
  splatMesh.quaternion.set(1, 0, 0, 0);
  splatMesh.position.set(0, 0, -1);
  splatMesh.scale.setScalar(0.5);
  scene.add(splatMesh);
})
.catch((error) => {
  console.warn(error);
});

## Loading additional formats .splat and .ksplat
These formats cannot be reliably auto-detected from the file contents, so we use two fall-back mechanism to enable support for these formats.

First, the auto-detection fails on these files, which triggers file type inference via URL/path file extension. If the URL contains the .splat or .ksplat extensions (stripping out query parameters etc.), we set the corresponding file type.


const splats = new SplatMesh({ url: "./butterfly.splat" });
scene.add(splats);

const ksplats = new SplatMesh({ url: "./butterfly.ksplat" });
scene.add(ksplats);
If the URL contains a path with no obvious file extension, you can set the field fileType when constructing a SplatMesh or PackedSplats.


// File type can't be auto-detected, so we set it explicitly
scene.add(new SplatMesh({
  url: "splatBin/0123456789abcdef",
  fileType: SplatFileType.SPLAT,
}));

scene.add(new SplatMesh({
  url: "ksplatBin/fedcba9876543210",
  fileType: SplatFileType.KSPLAT,
}));

# Procedural Splats
Forge makes it easy to create Gaussian splat collections procedurally, and includes some splat constructors that are useful for common tasks like creating a grid or text made of splats. The example "Procedural Splats" puts some of these to use in a scene.

## Adding splats to a collection
To create a PackedSplats with custom, procedurally-derived splats use the methods pushSplat or setSplat:


const splats = new PackedSplats();
const center = new THREE.Vector3(0, 0, 0);
const scales = new THREE.Vector3(0.1, 0.1, 0.1);
const quaternion = new THREE.Quaternion();
const opacity = 1.0;
const color = new THREE.Color()
splats.pushSplat(center, scales, quaternion, opacity, color);
...
Note that calling .pushSplat and .setSplat will automatically resize the PackedSplats array to fit the splat. Additionally, the center, scales, etc parameters are encoded into 16 bytes, and the original objects passed in (such as center: THREE.Vector3) are no longer used. Re-using these objects for all the splats is a good idea.

Alternatively, you can use the construct initializer callback:


const splats = new PackedSplats({
  construct: (splats) => {
    ...
    for (let i = 0; i < NUM_SPLATS; ++i) {
      // Compute splat #i
      ...
      splats.pushSplat(center, scales, quaternion, opacity, color);
    }
  },
});
Once you've created your PackedSplats, render it to the scene via a SplatMesh:


const mesh = new SplatMesh({ packedSplats: splats });
scene.add(mesh);
Alternatively, you can create the SplatMesh and its splats in the initializer, which internally passes your constructor to its contained PackedSplats:


const mesh = new SplatMesh({
  constructSplats: (splats) => {
    for (let i = 0; i < NUM_SPLATS; ++i) {
      // Compute splat #i
      ...
      splats.pushSplat(center, scales, quaternion, opacity, color);
    }
  },
});
scene.add(mesh);

## Grid

import { constructGrid } from "@forge-gfx/forge";

const grid = new SplatMesh({
  constructSplats: (splats) => constructGrid({
    splats,
    extents: new THREE.Box3(
      new THREE.Vector3(-10, -10, -10),
      new THREE.Vector3(10, 10, 10),
    ),
  }),
});
scene.add(grid);

### Required parameters
Parameter	Description
splats	PackedSplats object to add splats to
extents	min and max box extents of the grid

### Optional parameters
Parameter	Default	Description
stepSize	1	step size along each grid axis
pointRadius	0.01	spherical radius of each splat
pointShadowScale	2.0	relative size of the "shadow copy" of each splat placed behind it
opacity	1.0	splat opacity
color	RGB-modulated grid	splat color (THREE.Color) or function to set color for position: ((THREE.Color, THREE.Vector3) => void)
XYZ axis

import { constructAxes } from "@forge-gfx/forge";

const axes = new SplatMesh({
  constructSplats: (splats) => constructAxes({ splats }),
});
axes.position.set(0, 0, -1);
scene.add(axes);
Required parameters
Parameter	Description
splats	PackedSplats object to add splats to
Optional parameters
Parameter	Default	Description
scale	0.25	scale (splat scale along axis)
axisRadius	0.0075	radius of the axes (splat scale orthogonal to axis)
axisShadowScale	2.0	relative size of the "shadow copy" of each splat placed behind it
origins	[new THREE.Vector3()]	origins of the axes (default single axis at origin)

## Splat sphere

import { constructSpherePoints } from "@forge-gfx/forge";

const sphere = new SplatMesh({
  constructSplats: (splats) => constructSpherePoints({
    splats,
    maxDepth: 4,
  }),
});
scene.add(sphere);

### Required parameters
Parameter	Description
splats	PackedSplats object to add splats to

### Optional parameters
Parameter	Default	Description
origin	new THREE.Vector3()	center of the sphere (default: origin)
radius	1.0	radius of the sphere
maxDepth	3	maximum depth of recursion for subdividing the sphere. Warning: splat count grows exponentially with depth
filter	null	filter function to apply to each point, for example to select points in a certain direction or other function ((THREE.Vector3) => boolean)
pointRadius	0.02	radius of each oriented splat
pointThickness	0.001	flatness of each oriented splat
color	new THREE.Color(1, 1, 1)	color of each splat (THREE.Color) or function to set color for point: ((THREE.Color, THREE.Vector3) => void)

## Rasterizing Text

const splats = textSplats({
  text: string;
  font?: string;
  fontSize?: number;
  color?: THREE.Color;
  rgb?: THREE.Color;
  dotRadius?: number;
  textAlign?: "left" | "center" | "right" | "start" | "end";
  lineHeight?: number;
});
scene.add(splats);

### Required parameters
Parameter	Description
text	text string to display

### Optional parameters
Parameter	Default	Description
font	"Arial"	browser font to render text with
fontSize	32	font size in pixels/splats
color	new THREE.Color(1, 1, 1)	SplatMesh.recolor tint assuming white splats
rgb	new THREE.Color(1, 1, 1)	Individual splat color
dotRadius	0.8	splat radius (0.8 covers 1-unit spacing well)
textAlign	"start"	text alignment: "left", "center", "right", "start", "end"
lineHeight	1.0	line spacing multiplier, lines delimited by "\n"

## Turning images into splats

const image = imageSplats({
  url: string;
  dotRadius?: number;
  subXY?: number;
  forEachSplat?: (
    width: number,
    height: number,
    index: number,
    center: THREE.Vector3,
    scales: THREE.Vector3,
    quaternion: THREE.Quaternion,
    opacity: number,
    color: THREE.Color,
  ) => number | null;
});
scene.add(image);

### Required parameters
Parameter	Description
url	URL of the image to convert to splats (example: url: "./image.png")

### Optional parameters
Parameter	Default	Description
dotRadius	0.8	Radius of each splat, default covers 1-unit spacing well
subXY	1	Subsampling factor for the image. Higher values reduce resolution, for example 2 will halve the width and height by averaging
forEachSplat	undefined	Optional callback function to modify each splat before it's added. Return null to skip adding the splat, or a number to set the opacity and add the splat with parameter values in the objects center, rgba etc. were passed into the forEachSplat callback. Ending the callback in return opacity; will retain the original opacity.

### Example

// Load RGBA image from image.png, subsample it 2x
// horizontally and vertically, and create splats for
// the resulting pixels that have at least 10% opacity.
const image = imageSplats({
  url: "./image.png",
  subXY: 2,
  forEachSplat: (width, height, index, center, scales, quaternion, opacity, color) => {
    // Only keep splats with opacity 10% or higher
    return (opacity >= 0.1) ? opacity : null;
  },
});
scene.add(image);

## Particle Effects
Some of the building blocks are meant to serve as "code inspiration", showing how a particle effect animation can be achieved using a "stateless" dyno computation graph that uses only the splat index input to produce pseudo-random numbers that drive various randomized particle effects.

Note that splat sorting takes a little bit of time and can "lag behind" the splat updates each frame, so it's important that there is a reasonably stable correspondence between each frame's splat output for the same index.

### generators.staticBox(...options)
In staticBox you provide a 3D box to render random "static" splats within. The AABB is sliced up into a 3D grid of cells, and random X/Y/Z points within those cells are sampled each frame, retaining consistency in splat position between successive frames.

### generators.snowBox(...options)
Similarly, snowBox produces splat trajectories that move in a deterministic fashion over time, with high similarity between adjacent frames. See "VFX - Particle Simulation" for an example that creates a snowBox.

A snowBox instance has a collection of properties that can be tuned to achieve different particle effects. DEFAULT_SNOW and DEFAULT_RAIN are example parameter sets that look a lot like snow and rain, and can be used as a starting point for further tweaking: const mySnow = { ...DEFAULT_SNOW, density: 500 };


const snowControls = generators.snowBox({
  box,
  minY,
  numSplats,
  density,
  anisoScale,
  minScale,
  maxScale,
  fallDirection,
  fallVelocity,
  wanderScale,
  wanderVariance,
  color1,
  color2,
  opacity,
  onFrame,
});
scene.add(snowControls.snow);
Parameter	Default Value	Description
box	new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1))	min and max box extents of the snowBox
minY	Number.NEGATIVE_INFINITY	minimum y-coordinate to clamp particle position, which can be used to fake hitting a ground plane and lingering there for a bit
numSplats	calculated from box and density	number of splats to generate
density	100	density of splats per unit volume
anisoScale	new THREE.Vector3(1, 1, 1)	The xyz anisotropic scale of the splat, which can be used for example to elongate rain particles
minScale	0.001	Minimum splat particle scale
maxScale	0.005	Maximum splat particle scale
fallDirection	new THREE.Vector3(0, -1, 0)	The average direction of fall
fallVelocity	0.02	The average speed of the fall (multiplied with fallDirection)
wanderScale	0.01	The world scale of wandering overlay motion
wanderVariance	2	Controls how uniformly the particles wander in sync, more variance means more randomness in the motion
color1	new THREE.Color(1, 1, 1)	Color 1 of the two colors interpolated between
color2	new THREE.Color(0.5, 0.5, 1)	Color 2 of the two colors interpolated between
opacity	1	The base opacity of the splats
onFrame	undefined	Optional callback function to call each frame

# Splat Editing
Forge provides the ability to apply "edits" to splats as part of the standard SplatMesh pipeline. These edits take the form of a sequence of operations, applied one at a time to the set of splats in its packedSplats. Each operation evaluates a 7-dimensional field (RGBA and XYZ displacement) at each splat's center point in space that derives from 1 or more Signed Distance Field shapes (such as spheres, boxes, planes, etc.), blended together and across inside-outside boundaries.

The result is a an RGBA,XYZ value for each splat, which combined with SplatEditRgbaBlendMode.MULTIPLY/SET_RGB/ADD_RGBA can be used to create special effects. For example, simulating simple lighting can be done with MULTIPLY or ADD_RGBA to light up or adjust the color in regions of space, using spheres for point light sources or infinite cone for a spotlight. Using MULTIPLY with opacity=0 can be used to delete splats from a region of space. The splats can also be displaced in space using the XYZ values, and adjusted each frame to create smooth deformations in space.

## Creating a splat edit operation
A SplatEdit operation can be assigned to a particular SplatMesh through its .edits[] property or by adding the SplatEdit as a child of the SplatMesh in the scene hierarchy. If the SplatEdit has no SplatMesh ancestor, its edits will apply globally to all SplatMeshes whose editable property is set to the default true.


const edit = new SplatEdit({
  name?: string;
  rgbaBlendMode?: SplatEditRgbaBlendMode;
  sdfSmooth?: number;
  softEdge?: number;
  invert?: boolean;
  sdfs?: SplatEditSdf[];
});
scene.add(edit);

### Optional parameters
Parameter	Default	Description
name	undefined (auto‐generated to Edit <n>)	Name of this edit operation. If you omit it, a default "Edit 1", "Edit 2", … is assigned.
rgbaBlendMode	SplatEditRgbaBlendMode.MULTIPLY	How the SDF’s RGBA modifies each splat’s RGBA: multiply, overwrite RGB, or add RGBA.
sdfSmooth	0.0	Smoothing (in world‐space units) for blending between multiple SDF shapes at their boundaries.
softEdge	0.0	Soft‐edge falloff radius (in world‐space units) around each SDF shape’s surface.
invert	false	Invert the SDF evaluation (inside/outside swap).
sdfs	null	Explicit array of SplatEditSdf objects to include. If null, any child SplatEditSdf instances are used.

### RGBA blend modes
When creating a SplatEdit you can specify a rgbaBlendMode?: SplatEditRgbaBlendMode value from the enum to choose between 3 blend modes:

Blend Mode	Description
MULTIPLY	The RGBA of the splat is multiplied component-wise by the SDF’s RGBA value at that point in space. (default)
SET_RGB	Ignore the Alpha value in the SDF, but set the splat’s RGB to equal the SDF’s RGB value at that point.
ADD_RGBA	Add the SDF’s RGBA value at that point to the RGBA value of the splat. This can produce hyper-saturated results, but is useful to easily “light up” areas. Note that having non-zero opacity is often not what you want because low-opacity splats will be made more opaque.

## Adding an SDF RGBA-XYZ shape to the edit operation

const shape1 = new SplatEditSdf({
  type?: SplatEditSdfType;
  invert?: boolean;
  opacity?: number;
  color?: THREE.Color;
  displace?: THREE.Vector3;
  radius?: number;
});
edit.add(shape1);

### Optional parameters
Parameter	Default	Description
type	SPHERE	The SDF shape type: ALL, PLANE, SPHERE, BOX, ELLIPSOID, CYLINDER, CAPSULE, or INFINITE_CONE.
invert	false	Invert the SDF evaluation, swapping inside and outside regions.
opacity	1.0	Opacity / "alpha" value used differently by blending modes
color	Color(1, 1, 1)	RGB color applied within the shape.
displace	Vector3(0, 0, 0)	XYZ displacement applied to splat positions inside the shape.
radius	0.0	Shape-specific size parameter: sphere radius, box corner rounding, cylinder/capsule radius, or for the infinite cone the angle factor (opening half-angle = π/4 × radius).

### SDF Shapes
The following SDF shapes are available in the SplatEditSdfType enum:

SDF Type	Description	SDF Parameters
ALL	Affects all points in space	None
PLANE	Infinite plane	position, rotation
SPHERE	Sphere	position, radius
BOX	Box (with optional corner rounding)	position, rotation, sizes, radius
ELLIPSOID	Ellipsoid	position, rotation, sizes
CYLINDER	Cylinder	position, rotation, size_y
CAPSULE	Capsule	position, rotation, size_y
INFINITE_CONE	Infinite cone	position, rotation, radius=angle

## Adding multiple SDF RGBA-XYZ shapes to the edit operation
RGBA-XYZ values are computed by blending together values from all SDF shapes using the exponential "softmax" function, which is commutative (so blending order within a SplatEdit operation doesn't matter). The parameter SplatEdit.sdfSmooth controls the blending scale between SDF shapes, while SplatEdit.softEdge controls the scale of soft inside-outside shape boundaries. Their default values start at 0.0 and should be increased to soften the edges.

Note that XYZ displacement values are blended in the same way as RGBA, with a resulting displacement field that can be quite complex but "softly" blends between shapes. These RGBA-XYZ edits, along with time-based and overlapping fields can create many interesting animations and special effects, such as rippling leaves in the wind, an angry fire, or a looping water effect. Simply update the SplatEdit and SplatEditSdf objects and the operations will be applied immediately to the splats in the scene.

# Dyno shaders
The dyno shader graph system is one of the architectural pillars of Forge, allowing you to create custom computation graphs using Javascript (and optionally GLSL) that are compiled to GLSL and run on the GPU, similar to shader graph systems in modern 3D graphics engines.

A core component of this system is the class Dyno and its subclasses, which can be thought of as function blocks with multiple typed inputs and outputs. Values passed between such blocks are of type DynoVal<T>, where T must be a DynoType, representing a GPU type in GLSL. Using TypeScript, Forge ensures type safety and static validation of the GPU computation graph.

All dyno code is contained within src/dyno, and has definitions which cover all built-in GLSL ES 3.0 types ("int", "float", "vec", etc.) and most of the standard functions (mul, cross, texelFetch, etc.). Note that regular Javascript functions can't be part of a dyno computation graph: instead of x + y you should use dyno.add(x, y). You can also define your own custom types and dyno blocks, both by compositing existing dyno functions or by writing GLSL code directly.

Forge currently uses these Dynos in two main places:

Dynamically generating splats from SplatGenerator/SplatMesh into the scene
Computing the splat distance metric for CPU readback and sorting
At the lowest layer, these are executed as pseudo-compute shaders by the classes PackedSplats and Readback, respectively. A PackedSplats is a collection of splats stored in a cache-efficient 16-byte/splat format, which can be loaded from a splat file URL, or generated via dyno program that maps an integer index DynoVal<"int"> to a DynoVal<Gsplat>, a GLSL struct type that contains all the splat parameters. Similarly, Readback takes a dyno program that maps an index DynoVal<"int"> to a RGBA8 value via a DynoVal<"vec4">, producing a 32-bit value per index that can then be read back to the CPU for splat sorting.

Learning to build and use dyno programs is probably best approached by starting with the Particle Simulation example and by examining SplatMesh.constructGenerator() for a more complex graph. SplatMesh also has two injection points objectModifier and worldModifier that allow you to inject dyno component into the standard splat generation pipeline to modify an existing splat object before it is rendered.

## type DynoType
A DynoType can be either a string that corresponds to a built-in GLSL type, or { type: "MyType" } for a user-defined type. These types are used both for identifying value types DynoVal<T extends DynoType> and for declaring input/output types for Dyno blocks, for example { index: "int" } or { gsplat: Gsplat } (Gsplat is defined as { type: "Gsplat" }). Forge uses these to enforce TypeScript constraints on inputs+outputs of Dyno blocks to generate correct GLSL code.

### Build-in types
A built-in GLSL type can be single-valued ("int", "uint", "float", "bool"), vector ("vec4", "ivec3", "bvec2"), matrix ("mat4", "mat2x3"), or a sampler ("sampler2D", "usampler3D", etc).

### Custom types
Forge defines a handful of custom types that are useful: Gsplat, TPackedSplats, SdfArray, TRgbaArray, and SplatSkinning. For example, in src/dyno/splats.ts we define Gsplat as { type: "Gsplat" } along with a helper function:


export const defineGsplat = unindent(`
  struct Gsplat {
    vec3 center;
    uint flags;
    vec3 scales;
    int index;
    vec4 quaternion;
    vec4 rgba;
  };
  const uint GSPLAT_FLAG_ACTIVE = 1u << 0u;

  bool isGsplatActive(uint flags) {
    return (flags & GSPLAT_FLAG_ACTIVE) != 0u;
  }
`);
When declaring a new user type, you should also define how that type will appear in GLSL, along with any other definitions or utility functions that are useful for that type. When creating a new Dyno block you can then include these definitions wherever a Gsplat type is used to make sure these global definitions are available.

## type DynoVal<T extends DynoType>
A DynoVal<T extends DynoType> corresponds to a value of type T in the GLSL computation graph. These values can come from a literal/constant value, a uniform (a value that can be updated every frame from your program), or the output of a Dyno block.

### DynoLiteral / dynoLiteral
The class DynoLiteral<T extends DynoType> is a DynoVal whose constant value is given as a GLSL literal string. For example, new DynoLiteral("float", "1.0") or new DynoLiteral("vec3", "vec3(1.0, 2.0, 3.0)") produce DynoVals that can be used as inputs in a dyno graph.

The helper function dynoLiteral(type, literal) is a shorthand for new DynoLiteral(type, literal).

### DynoConst / dynoConst
Creating a new DynoConst<T extends DynoType> is similar to a DynoLiteral, but the value is given as a Javascript value, which is converted to a GLSL literal string. For example, new DynoConst("float", 1.0) or new DynoConst("vec3", new THREE.Vector3(1.0, 2.0, 3.0)) produce DynoVals that can be used as inputs in a dyno graph.

You can also use the helper function dynoConst(type, value) to create a DynoConst.

### DynoOutput
A DynoOutput is created internally in the dyno system to represent a particular named output of a Dyno block. For example, dyno.splitGsplat takes a DynoVal<Gsplat> as input and produces multiple outputs including index, center, rgba, etc., and selecting a particular output will yield the appropriate typed DynoOutput:


// opacity is a DynoOutput and also a DynoVal<"float">
const { opacity } = dyno.splitGsplat(gsplat);

## class Dyno<InTypes, OutTypes>
A Dyno an abstract block that has named, typed inputs and outputs, both as part of its type signature (for TypeScript checking) and stored in the class (for runtime access). When creating a new Dyno the following constructor options are available:

Option	Description
inTypes	A map from input name to DynoType, for example { index: "int" }. This must match the template parameter InTypes of the Dyno class.
outTypes	A map from output name to DynoType, for example { rgba: "vec4" }. This must match the template parameter OutTypes of the Dyno class.
inputs	A mapping of input values that are passed to the Dyno, where the type of DynoVal<T> must match the DynoType in inTypes.
update	Optional function that is called (no return value) each time a program containing this Dyno is executed. This can for example be used to update any uniforms before running.
globals	Optional function that outputs global GLSL definitions needed by this block, as an array of strings. Duplicate global definition strings within the same program will be deduplicated, so you should always define all the globals you need for this block without regard to whether they are defined elsewhere.
statements	Optional function that outputs the GLSL statements to execute for this block as an array of strings. When defining a custom Dyno that executes GLSL, this is where your code will go.
generate	Called internally by the dyno compiler to generate the globals, statements, and any uniforms needed for this block. The default generate implementation will call globals and statements if they are defined and return these to the compiler.
The methods globals, statements, and generate all take a GenerateContext object as argument, which consists of three properties:

Property	Description
inputs	A map from the input key to the actual GLSL variable name of that input value. The compiler will create unique names for values passed between blocks so you can reuse the same input key. If an input is NOT attached, the value will be undefined.
outputs	A map from the output key to the actual GLSL variable name of that output value. The compiler will create unique names for values passed between blocks so you can reuse the same output key. If an output is NOT connected, the value will be undefined.
compile	An instance of class Compilation that stores the context for the ongoing compilation, including global defines, statements to execute, uniforms, indentation level, etc.
Typically you will want to define a Dyno subclass that constructs a Dyno instance with the appropriate globals, statements, and update etc. for your block. When generating code, use the passed in GenerateContext to get the names of inputs and outputs, and generate code that uses those names (via string interpolation or similar).

### Using a Dyno
Once defined, using your Dyno will typically be done as follows:


const { sum } = new dyno.Add({ a, b }).outputs;
// Or equivalently:
const { sum } = dyno.add(a, b).outputs;
// For Dynos that implement HasDynoOut<T> you can also do
const sum = dyno.add(a, b);
The property outputs is a map from output name to a DynoVal<T> for each output type in outTypes (internally they are DynoOutputs).

For a Dyno that only has a single output, you can also implement the method dynoOut(): DynoValue<T> (which corresponds to the interface HasDynoOut<T>) to pick out a default output from outputs, which can help reduce redundant .outputs calls.

### Helper functions for GLSL code
unindentLines(s: string): string[]: Takes a multi-line string, removes common leading whitespace from each line, and returns the resulting array of strings. This can be useful to prepare an array of statements from a block of GLSL code:


const leftAlignedLines = unindentLines(`
    float sqr(float x) {
      return x * x;
    }
`);
unindent(s: string): string: Same as for unindentLines but joins the resulting lines into a single string. This is useful for defining a globals, which are de-duplicated based on the entirety of the string rather than individual lines.

## class DynoBlock<InTypes, OutTypes>
A DynoBlock is a Dyno that is like a "module" in that it can contain a Dyno subgraph internally that is created in a closure. Although you can construct a DynoBlock directly it is more ergnomic to use the helper function dynoBlock:


const myGsplatGenerator = dyno.dynoBlock(
  { index: "int" }, // Inputs
  { gsplat: Gsplat }, // Outputs
  ({ index }) => { // Closure mapping inputs to outputs
    let gsplat = dyno.readPackedSplat(myPackedSplats, index);
    const opacity = dyno.dynoConst("float", 1.0);
    gsplat = dyno.combineGsplat({ gsplat, opacity });
    return { gsplat };
  },
);
The first argument is mapping from input keys to DynoType, the second for output keys, and the third argument is a closure that constructs a dyno graph from the input DynoVals and any other external DynoVals (such as myPackedSplats in this example), and must return a map of DynoVals that match the output keys. An optional fourth argument allows you to pass in additional arguments update (called before program execution) and globals (for any global definitions needed by the block).

## Helpers to design Dynos
When creating blocks that are simple operations of 1-3 inputs you can use the helper classes UnaryOp, BinaryOp, and TrinaryOp, which help standardize the interface. You must override the class' statements or generate method to generate the code. See examples in src/dyno/math.ts for how to use them.

# Dyno Standard Library
The Forge dyno system provides a standard library of Dyno blocks that cover most of the built-in functions in GLSL ES 3.0, including data conversion, logic, math, trigonometry, linear algebra, texture lookups, transforms, managing uniform variables, hashing & RNG, and of course managing splat data.

We use the convention of PascalCase for the names of the Dyno classes, and camelCase for the names of equivalent helper functions that are more ergonomic to use. For example, you can equivalently write:


const sum = new dyno.Add({ a, b });
const sum = dyno.add(a, b);
The second form will create the dyno.Add class with appropriate constructor options. In the tables below we will opt for the camelCase variant for brevity.

## Data type conversion
The following functions use standard GLSL casting rules, which means that for example bool(1) will return true and bool(0) will return false.

Function	Description
bool(value): DynoVal<"bool">	Convert a value to a boolean
int(value): DynoVal<"int">	Convert a value to a signed integer
uint(value): DynoVal<"uint">	Convert a value to an unsigned integer
float(value): DynoVal<"float">	Convert a value to a floating-point number
bvec<N>(value): DynoVal<"bvec<N>">	Convert a value to a boolean vector of length N
ivec<N>(value): DynoVal<"ivec<N>">	Convert a value to a signed integer vector of length N
uvec<N>(value): DynoVal<"uvec<N>">	Convert a value to an unsigned integer vector of length N
vec<N>(value): DynoVal<"vec<N>">	Convert a value to a floating-point vector of length N
mat<N>(value): DynoVal<"mat<M>">	Convert a value to a NxN matrix
floatBitsToInt(value: DynoVal<"float">): DynoVal<"int">	Reinterpret the bits of a float as an integer
floatBitsToUint(value: DynoVal<"float">): DynoVal<"uint">	Reinterpret the bits of a float as an unsigned integer
intBitsToFloat(value: DynoVal<"int">): DynoVal<"float">	Reinterpret the bits of an integer as a float
uintBitsToFloat(value: DynoVal<"uint">): DynoVal<"float">	Reinterpret the bits of an unsigned integer as a float
packSnorm2x16(value: DynoVal<"vec2">): DynoVal<"uint">	Encode a vec2 from -1..1 as a 16-bit signed integer and pack into a 32-bit uint
unpackSnorm2x16(value: DynoVal<"uint">): DynoVal<"vec2">	Decode a 32-bit uint as a vec2 from -1..1
packUnorm2x16(value: DynoVal<"vec2">): DynoVal<"uint">	Encode a vec2 from 0..1 as a 16-bit unsigned integer and pack into a 32-bit uint
unpackUnorm2x16(value: DynoVal<"uint">): DynoVal<"vec2">	Decode a 32-bit uint as a vec2 from 0..1
packHalf2x16(value: DynoVal<"vec2">): DynoVal<"uint">	Encode a vec2 as two float16 values and pack into a 32-bit uint
unpackHalf2x16(value: DynoVal<"uint">): DynoVal<"vec2">	Decode a 32-bit uint as two float16 values
uintToRgba8(value: DynoVal<"uint">): DynoVal<"vec4">	Decode a 32-bit uint as a vec4 of 8-bit unsigned integers

## Logic
The following logic and bit operations follow standard GLSL ES 3.0 semantics.

Function	Description
and(a, b)	Logical (for bool output) or bit-wise (for integer output) AND
or(a, b)	Logical (for bool output) or bit-wise (for integer output) OR
xor(a, b)	Logical (for bool output) or bit-wise (for integer output) XOR
not(a)	Logical NOT (for bool output) or bit-wise NOT (for integer output)
lessThan(a, b)	Less than
lessThanEqual(a, b)	Less than or equal to
greaterThan(a, b)	Greater than
greaterThanEqual(a, b)	Greater than or equal to
equal(a, b)	Equal
notEqual(a, b)	Not equal
any(a: DynoVal<"bvec<N>">)	True if any component of the vector is true
all(a: DynoVal<"bvec<N>">)	True if all components of the vector are true
select(cond, t: DynoVal<T>, f: DynoVal<T>): DynoVal<T>	Select between two values based on a condition
compXor(a)	Component-wise XOR of a boolean or integer vector

## Math
The following math functions follow standard GLSL ES 3.0 semantics, for example rules around multiplication of vector and matrix types.

Function	Description
add(a, b)	Addition
sub(a, b)	Subtraction
mul(a, b)	Multiplication
div(a, b)	Division
imod(a, b)	Integer modulus
mod(a, b)	Floating-point modulus
modf(a)	Seperate a floating-point number into its fractional and integer parts
neg(a)	Negation
abs(a)	Absolute value
sign(a)	Sign of a number
floor(a)	Floor of a floating-point number
ceil(a)	Ceiling of a floating-point number
trunc(a)	Truncate a floating-point number toward negative infinity
round(a)	Round a floating-point number to the nearest integer
fract(a)	Fractional part of a floating-point number
pow(a, b)	a ^ b
exp(a)	e ^ a
exp2(a)	2 ^ a
log(a)	Natural logarithm of a
log2(a)	Base-2 logarithm of a
sqr(a)	a * a
sqrt(a)	Square root of a
inversesqrt(a)	1 / sqrt(a)
min(a, b)	Minimum of two values
max(a, b)	Maximum of two values
clamp(a, min, max)	Clamp a value between two others
mix(a, b, t)	Linear interpolation between two values
step(edge, x)	0 if x < edge, 1 otherwise
smoothstep(edge0, edge1, x)	0 if x <= edge0, 1 if x >= edge1, otherwise a smooth Hermite interpolation between 0 and 1
isNan(a)	True if a is NaN
isInf(a)	True if a is infinite

## Trigonometry
Function	Description
radians(degrees)	Convert degrees to radians
degrees(radians)	Convert radians to degrees
sin(x)	Sine of x
cos(x)	Cosine of x
tan(x)	Tangent of x
asin(x)	Arcsine of x
acos(x)	Arccosine of x
atan(x)	Arctangent of x
atan2(y, x)	Arctangent of y/x
sinh(x)	Hyperbolic sine of x
cosh(x)	Hyperbolic cosine of x
tanh(x)	Hyperbolic tangent of x
asinh(x)	Inverse hyperbolic sine of x
acosh(x)	Inverse hyperbolic cosine of x
atanh(x)	Inverse hyperbolic tangent of x

## Linear Algebra
Function	Description
length(a)	Length of a vector
distance(a, b)	Distance between two vectors
dot(a, b)	Dot product of two vectors
cross(a: DynoVal<"vec3">, b: DynoVal<"vec3">)	Cross product of two 3-dimensional vectors
normalize(a)	Normalize a vector
faceforward(a, b, c)	Returns a if dot(c, b) < 0, otherwise returns -a
reflectVec(incident, normal)	Reflect a vector around a normal
refractVec(incident, normal, eta)	Refract a vector around a normal given an index of refraction
split(a)	Split a vector into its components
combine(a)	Create a vector from components, or inject components into an existing vector
projectH(a)	Project a vector in homogeneous coordinates
extendVec(a, b)	Extend a vector with an additional component
swizzle(a, select)	Select a subset of components from a vector
compMult(a, b)	Component-wise multiplication of two vectors
outer(a, b)	Outer product of two vectors
transpose(a)	Transpose a matrix
determinant(a)	Determinant of a matrix
inverse(a)	Invert a matrix

## Texture lookups
Function	Description
textureSize(texture, lod?)	Return the size of a texture
texture(texture, coord, bias?)	Sample a texture at a continuous coordinate
texelFetch(texture, coord, lod?)	Fetch a discrete texel value from a texture

## Transforms
Function	Description
transformPos(position, { scale?, scales?, rotate?, translate? })	Performs a transform of a position in 3D space, with optional uniform scale, anisotropic scales, quaternion rotate, and translate
transformDir(dir, { scale?, scales?, rotate? })	Performs a transform of a direction in 3D space, with optional uniform scale, anisotropic scales, and quaternion rotate
transformQuat(quat, { rotate? })	Rotate a quaternion

## Uniform variables
Constant values and literals in dyno programs should not be changed often because it incurs a recompilation. To have a variable that can be changed every frame, you can declare a "uniform". The base class for uniforms provided by Forge is DynoUniform, which importantly contains a type, current value, and update function.

To update a uniform, simply assign a new value to the value property of the uniform. Alternatively, you can construct a DynoUniform with an update function that is called for each execution. This function can either update value directly, or return any non-undefined value to have it updated.

Use the following helper functions for more ergonomic creation of uniforms.

Function	Description
dynoBool(value)	Create a boolean uniform
dynoUint(value)	Create an unsigned integer uniform
dynoInt(value)	Create a signed integer uniform
dynoFloat(value)	Create a floating-point uniform
dynoBvec<N>(value)	Create a boolean vector of length N
dynoUvec<N>(value)	Create an unsigned integer vector of length N
dynoIvec<N>(value)	Create a signed integer vector of length N
dynoVec<N>(value)	Create a floating-point vector of length N
dynoMat<N>(value)	Create an NxN matrix
dynoMat<N>x<M>(value)	Create an NxM matrix
dynoUsampler2D(texture)	Create a uniform that lets you sample a 2D uint texture
dynoIsampler2D(texture)	Create a uniform that lets you sample a 2D int texture
dynoSampler2D(texture)	Create a uniform that lets you sample a 2D float texture
dynoUsampler2DArray(texture)	Create a uniform that lets you sample a 2D uint texture array
dynoIsampler2DArray(texture)	Create a uniform that lets you sample a 2D int texture array
dynoSampler2DArray(texture)	Create a uniform that lets you sample a 2D float texture array
dynoUsampler3D(texture)	Create a uniform that lets you sample a 3D uint texture
dynoIsampler3D(texture)	Create a uniform that lets you sample a 3D int texture
dynoSampler3D(texture)	Create a uniform that lets you sample a 3D float texture
dynoUsamplerCube(texture)	Create a uniform that lets you sample a cube uint texture
dynoIsamplerCube(texture)	Create a uniform that lets you sample a cube int texture
dynoSamplerCube(texture)	Create a uniform that lets you sample a cube float texture
dynoSampler2DShadow(texture)	Create a uniform that lets you sample a 2D float shadow texture
dynoSampler2DArrayShadow(texture)	Create a uniform that lets you sample a 2D float shadow texture array
dynoSamplerCubeShadow(texture)	Create a uniform that lets you sample a cube float shadow texture

## Hashing & Random number generation
When a dyno program executes, each invocation for a given splat/index is effectively run in parallel, separate from the rest. In order to incorporate randomness into a dyno program, you must use the inputs available to the program, which is often just the index of the splat itself. Forge provides functions to hash any scalar or vector (integer or float) into 1-4 components of either a uint32 or float, using the PCG random number generator.

Function	Description
pcgMix(value): DynoVal<"uint">	Mix scalar or vector values into a single uint32 value that can be used as a seed for PCG
pcgNext(state): DynoVal<"uint">	Advance the PCG random number generator by one step
pcgHash(state): DynoVal<"uint">	Hash the PCG state into a random uint32
hash(value): DynoVal<"uint">	Hash a scalar or vector value into a random uint32
hash2(value): DynoVal<"uvec2">	Hash a scalar or vector value into a random uvec2
hash3(value): DynoVal<"uvec3">	Hash a scalar or vector value into a random uvec3
hash4(value): DynoVal<"uvec4">	Hash a scalar or vector value into a random uvec4
hashFloat(value): DynoVal<"float">	Hash a scalar or vector value into a random float
hashVec2(value): DynoVal<"vec2">	Hash a scalar or vector value into a random vec2
hashVec3(value): DynoVal<"vec3">	Hash a scalar or vector value into a random vec3
hashVec4(value): DynoVal<"vec4">	Hash a scalar or vector value into a random vec4

## Splat data
Forge makes it easier to work with splat data by defining the GLSL struct Gsplat which contains the following fields:

Field	Type	Description
center	vec3	Center of the splat
flags	uint	Flags for the splat (0x1 = active)
scales	vec3	Scales of the splat
index	int	Index of the splat in the array
quaternion	vec4	Quaternion orientation of the splat
rgba	vec4	RGBA color of the splat
This way, you can pass around a DynoVal<Gsplat> that contains the all the properties of a splat. The following helper functions are provided to extract the splat data from a PackedSplats:

Function	Description
numPackedSplats(packedSplats)	Get the number of splats in a PackedSplats
readPackedSplat(packedSplats, index)	Read a particular splat from a PackedSplats by index
readPackedSplatRange(packedSplats, index, base, count)	Read a particular splat from a PackedSplats by index but restricted to the given range
splitGsplat(gsplat)	Split a Gsplat into its components
combineGsplat(gsplat)	Create a Gsplat from components (or inject components into an existing Gsplat)
gsplatNormal(gsplat)	Get the Gsplat normal, defined as whichever X/Y/Z axis has the smallest scale
transformGsplat(gsplat, { scale?, rotate?, translate?, recolor? })	Transform a Gsplat and all its components by the given transform

# Controls
A program using Forge can use any camera control scheme that is compatible with THREE.js and will typically manipulate a THREE.Camera object's transform. Forge also ships with simple, intuitive controls for navigating 3D space that use the keyboard + mouse, game pad, or mobile multi-touch. To add these controls, you can create a ForgeControls instance:


const controls = new ForgeControls({
  canvas: HTMLCanvasElement;
});

renderer.setAnimationLoop((time) => {
  renderer.render(scene, camera);
  controls.update(camera);
});
ForgeControls instantiates two classes FpsMovement and PointerControls that it updates internally. You can also instantiate and use these two classes separately:

## class FpsMovement
FpsMovement implements controls that will be familiar to anyone who plays First Person Shooters using keyboard + mouse or a gamepad. Creating a FpsMovement instance provides many parameters:


const fpsMovement = new FpsMovement({
  moveSpeed?: number;
  rollSpeed?: number;
  stickThreshold?: number;
  rotateSpeed?: number;
  keycodeMoveMapping?: { [key: string]: THREE.Vector3 };
  keycodeRotateMapping?: { [key: string]: THREE.Vector3 };
  gamepadMapping?: {
    [button: number]: "shift" | "ctrl" | "rollLeft" | "rollRight";
  };
  capsMultiplier?: number;
  shiftMultiplier?: number;
  ctrlMultiplier?: number;
  xr?: THREE.WebXRManager;
});
When gamepads are connected, FpsMovement will always use gamepad index 0 for twin-stick movement and rotation.
If xr is passed in, the WebXR controllers can be used as a split gamepad to control movement and rotation. (tested on Quest 3)

### Optional parameters
Parameter	Default	Description
moveSpeed	1.0	Base movement speed
rollSpeed	2.0	Speed of roll rotation
stickThreshold	0.1	Deadzone for gamepad analog sticks
rotateSpeed	2.0	Speed of rotation when using gamepad or keys
keycodeMoveMapping	{...WASD_KEYCODE_MOVE, ...ARROW_KEYCODE_MOVE}	Maps keyboard keys to movement directions
keycodeRotateMapping	{...QE_KEYCODE_ROTATE, ...ARROW_KEYCODE_ROTATE}	Maps keyboard keys to rotation directions
gamepadMapping	{4: "rollLeft", 5: "rollRight", 6: "ctrl", 7: "shift"}	Maps gamepad buttons to actions
capsMultiplier	10.0	Speed multiplier when Caps Lock is active
shiftMultiplier	5.0	Speed multiplier when Shift is held
ctrlMultiplier	0.2	Speed multiplier when Ctrl is held
xr	undefined	Optional WebXR manager for XR controller stick support
update(deltaTime, control)
Call this method in your render loop with control set to the object to control (THREE.Camera or a THREE.Object3D that contains it), with deltaTime in seconds since the last update. The update method handles:

Processing keyboard input for movement and rotation
Processing gamepad input for movement and rotation
Applying speed multipliers based on modifier keys and gamepad buttons
Applying movement and rotation to the controlled object

## class PointerControls
PointerControls implements pointer/mouse/touch controls on the canvas, for both desktop and mobile web applications. Creating a new control:


const pointerControls = new PointerControls({
  canvas: HTMLCanvasElement;
  rotateSpeed?: number;
  slideSpeed?: number;
  scrollSpeed?: number;
  reverseRotate?: boolean;
  reverseSlide?: boolean;
  reverseSwipe?: boolean;
  reverseScroll?: boolean;
  moveInertia?: number;
  rotateInertia?: number;
  doublePress?: ({
    position,
    intervalMs,
  }: { position: THREE.Vector2; intervalMs: number }) => void;
})

### Require parameters
Parameter	Description
canvas	The HTML canvas element to attach pointer events to

### Optional parameters
Parameter	Default	Description
rotateSpeed	0.002	Speed of rotation when dragging
slideSpeed	0.006	Speed of sliding when dragging with right button or two fingers
scrollSpeed	0.0015	Speed of movement when using mouse wheel
reverseRotate	false	Reverse the direction of rotation
reverseSlide	false	Reverse the direction of sliding
reverseSwipe	false	Reverse the direction of swipe gestures
reverseScroll	false	Reverse the direction of scroll wheel movement
moveInertia	0.15	Inertia factor for movement
rotateInertia	0.15	Inertia factor for rotation
doublePress	undefined	Callback function for double-press/double-tap events

### update(deltaTime, control)
Call this method in your render loop with control set to the object to control (THREE.Camera or a THREE.Object3D that contains it), with deltaTime in seconds since the last update.

The update method handles:

Processing pointer/mouse/touch movements for rotation
Handling dual-press touch gestures for camera movement
Applying scroll wheel input
Calculating and applying inertia for smooth motion
Updating the camera position and orientation

## Adding a simple GUI to configure controls
Add lil-gui to your package (npm add lil-gui) to provide a simple configurable GUI.


import GUI from "lil-gui";

const gui = new GUI({ title: "Settings + Controls" }).close();
const controlOptions = {
  reversePointerFps: false,
  reversePointerPan: false,
};
gui
  .add(controlOptions, "reversePointerFps")
  .name("Reverse Pointer FPS")
  .onChange((value: boolean) => {
    pointerControls.reverseRotate = value;
    pointerControls.reverseScroll = value;
  });
gui
  .add(controlOptions, "reversePointerPan")
  .name("Reverse Pointer Pan")
  .onChange((value: boolean) => {
    pointerControls.reverseSlide = value;
    pointerControls.reverseSwipe = value;
  });

# Performance Tuning
Rendering millions of splats at 60+ fps can be a demanding task, especially for mobile-class GPUs. Each splat is rendered as two triangles that span the footprint of a Gaussian up to sqrt(8) standard deviations (default value) from the center. Each splat is rendered as a transparent object and must be blended back-to-front.

As a quick rule-of-thumb, the following "splat budgets" are recommended:

Quest 3: 1 million splats or less, not too many splats concentrated in a small area
Android phone: 1-2 million splats
iPhone: 1-3 million splats
Computer: 1-5 million splats (10-20+ million on some desktops)
Each splat incurs overhead in transforming it via SplatAccumulator for sorting and rendering, and at around 1 million splats this becomes a bottleneck on some systems. Unintuitively, when a large number of splats are concentrated in a small area (for example 500K splats from a Trellis object at a small screen scale) they can bottleneck the GPU's rendering and blending ability.

## maxStdDev
Adjust ForgeRenderer.maxStdDev (either directly on ForgeRenderer or via constructor options) to a value less than the default Math.sqrt(8). This limits the extent of the Gaussian fall-off, which by default is approx 2.8. For VR a good value is Math.sqrt(5), which is perceptually very similar to the default.

## THREE.WebGLRenderer.antialias
When constructing a THREE.WebGLRenderer you should set antialias: false (default value) to avoid the overhead of multisampling. Rendering splats doesn't benefit from multisampling, and adds a significant amount of overhead when drawing millions of splats.

## renderer.setPixelRatio(window.devicePixelRatio)
Although ForgeRenderer is designed to work with any devicePixelRatio, it may impact performance due to the increased number of pixels to render and blend. If your scene consists of mostly splats, consider whether you have enough splats to justify the high DPI rendering.

# Community Resources
A collection of resources and examples created by the community. To add your own, please submit a PR to edit this page at forge-gfx/forge: https://github.com/forge-gfx/forge/blob/main/docs/docs/community-resources.md

## Discord
Join the Forge Discord to connect with other users and developers: https://discord.gg/W39qmSKemS

React Examples
Forge can be used alongside or within React for declarative scene management, dynamic rendering, and state management between your user interface and the 3D scene. See the following examples for how to use Forge with React.

forge-react-basic: A basic example of creating a <canvas> and THREE.js scene with Forge: https://github.com/forge-gfx/forge-react-basic
forge-react-r3f: Use Forge declaratively in React with React Three Fiber: https://github.com/forge-gfx/forge-react-r3f
forge-react-router: An example of using Forge and React Three Fiber with React Router v7 framework mode with SSR: https://github.com/forge-gfx/forge-react-router
forge-react-nextjs: An example of using Forge and React Three Fiber with Next.js App Router: https://github.com/forge-gfx/forge-react-nextjs
